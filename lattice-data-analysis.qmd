---
title: "Lattice Data Analysis"
author: "Samuel Gunz, Martin Emons, Mark D. Robinson"
format: html
editor: visual
---

In contrast to point pattern based methods, we could view the location of cells or spots as a fixed lattice and measure the corresponding marker expression at each location. HTS-based spatial transcriptomic technologies produce data on a regular lattice (i.e., evenly spaced spots or beads of uniform size and shape), whereas imaging-based technologies yield irregular lattice structures (i.e., with variable cell sizes and shapes, and non-uniform spacing).

For this representation of the cells we will rely on the `SpatialFeatureExperiment` package. For preprocessing of the dataset we refer the reader to the vignette of the `Voyager` package (Moses et al. 2023). The `Voyager` package also provides wrapper functions around the package `spdep` (Pebesma and Bivand 2023) that work directly on the `SpatialFeatureExperiment` object. The package `spdep` is designed for the ananlysis of spatial data with lattice structure.

# Dependencies

```{r}
source("utils.R")
theme_set(theme_light())
```

# Setup and Preprocessing

```{r}
# Load the dataset
sfe <- SFEData::McKellarMuscleData(dataset = "full")

# Filter and normalize the data
sfe_tissue <- sfe[, colData(sfe)$in_tissue]
sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,]
sfe_tissue <- scater::logNormCounts(sfe_tissue)

# Build the spatial graph
colGraph(sfe_tissue, "visium") <- findVisiumGraph(sfe_tissue)
```

# Introduction to Lattice Data

## Definition

Lattice data refers to spatial data collected at fixed locations arranged in a regular or irregular grid (lattice). Each location has a defined spatial unit, and the sampling locations are fixed rather than random. This approach contrasts with point pattern analysis, where we assume that the locations were generated by a stochastic process.

```{r}
plotSpatialFeature(sfe_tissue,
                   "nCounts", 
                   colGeometryName = "spotPoly")
```
As can be seen here, the Visium dataset is a regular lattice. The color shows the number of counts detected in each Visium spot.

```{r}
plotSpatialFeature(sfe_tissue,
                   "nCounts", 
                   annotGeometryName = "myofiber_simplified")
```
Here see the segemntation of individual cells, which can be seen as an irregular lattice.

## Spatial weight matrix

For lattice data analysis, a key concept is the *spatial weight matrix*, which models the spatial relationships between units. Various methods exist for constructing this matrix, such as contiguity-based (direct neighbors), graph-based, or distance-based methods.

For Visium, the most straightforward way is to take the next neighbours of each spot. This is done using the function `findVisiumGraph`.

```{r}
colGraph(sfe_tissue, "visium") <- findVisiumGraph(sfe_tissue)
```

```{r}
plotColGraph(sfe_tissue, 
             colGraphName = "visium",
             colGeometryName = "spotPoly") +
    theme_void()
```

In an irregular lattice the task of finding a spatial neighbourhood matrix is more complex, as different options exist. One option is to base the neighbourhood graph on neighbours that are in direct contact with each other. The method `poly2nb` creates a neihbourhood matrix with direct neighbours.

```{r}
annotGraph(sfe_tissue, "myofiber_poly2nb") <- 
  findSpatialNeighbors(sfe_tissue,
                       type = "myofiber_simplified",
                       MARGIN = 3,
                       method = "poly2nb", # wraps the spdep function with the same name
                       zero.policy = TRUE)
```


```{r}
plotAnnotGraph(sfe_tissue,
               annotGraphName = "myofiber_poly2nb", 
               annotGeometryName = "myofiber_simplified") + 
  theme_void()
```
```{r}
annotGraph(sfe_tissue, "knn5") <- 
  findSpatialNeighbors(sfe_tissue,
                       type = "myofiber_simplified",
                       MARGIN = 3, # to use the annotation geometry
                       method = "knearneigh", # wraps the spdep function with the same name
                       k = 5,
                       zero.policy = TRUE)
```

```{r}
plotAnnotGraph(sfe_tissue,
               annotGraphName = "knn5", 
               annotGeometryName = "myofiber_simplified") + 
  theme_void()
```
<!-- In the case of Visium data, we don't have cell level gene expression information and therefore continue with the analysis using the spatial analysis of the regularly spaced spots. -->

# Spatial autocorrelation

Spatial autocorrelation measures the association between spatial units while recognizing that the spatial units are not independent measurement. These measures can be global (summarizing the entire field) or local (providing statistics for individual locations).

# Global Measures

Global methods give us an overview over the entire field of view and summarize the spatial distribution of the cells (for a given measurement such as gene expression) in a single value. The metrics are a function of the weight matrix and the variables of interest.

In general, a global spatial autocorrelation measure has the form of a double sum over all locations $i,j$

$$\sum_i \sum_j f(x_i,x_j) w_{ij}$$
where $f(x_i,x_j)$ is the measure of association between features of interest and $w_{ij}$ scales the relationship by a spatial weight as defined in the weight matrix $W$.

## Moran's $I$

Moran's $I$ is the most prominent measure of spatial autocorrelation. The values are bounded by $-1$ and $1$. The expected value is close to $0$ for large $n$ ($\mathbb{E}(I) = -1/(n-1)$). A value higher than the expected value indicates spatial auto-correlation. Negative values indicate negative auto-correlation. Spatial auto-correlation means that similar values tend to be found together in the tissue. In fact, Moran's $I$ can be interpreted as the Pearson correlation between the value at location $i$ and the averages value of the neigbours of $i$, (neighbours as defined in the weight matrix $W$).

```{r}
calculateUnivariate(t(colData(sfe_tissue)[,c("nCounts", "nGenes")]), 
                    type = "moran",
                    listw = colGraph(sfe_tissue, "visium"))
```



```{r}
sfe_tissue <- colDataUnivariate(sfe_tissue, features = c("nCounts", "nGenes"), 
                                colGraphName = "visium", nsim = 1000, type = "moran.mc")

plotMoranMC(sfe_tissue, c("nCounts"))
```
Here we can see the Moran's $I$ values for the number of counts and genes that were identified in the Visium dataset and a permutation based null distribution. As we can see, the Moran's $I$ values both indicates positive spatial autocorrelation and is highly significant.

# Local Measures for Univariate Data

## Local Moran's $I$

Local Moran's $I$ provides a measure of spatial autocorrelation at each location, highlighting local clusters of similarity or dissimilarity.

```{r}
sfe_tissue <- colDataUnivariate(sfe_tissue, "localmoran", features = c("nCounts"), )

plotLocalResult(sfe_tissue, "localmoran", features = c("nCounts"),
                colGeometryName = "spotPoly")

plotLocalResult(sfe_tissue, "localmoran", features = c("nCounts"), "-log10p_adj",
                colGeometryName = "spotPoly")
```
In the local version of Moran's $I$ the interpretation is the same as the global version). When interpreting local autocorrelation measures, it is important to consider both the effect size estimates and the significance level. Since the significance level is calculated for each spot separately, it is recommended to adjust for multiple testing (e.g., Benjamini and Hochberg methods). The local Moran's $I$ statistics reveal locations in the tissue that have similar values to their neighbours (e.g., the upper part of the tissue). 

# Sources

This tutorial is partly based on the following `Voyager` vignette: https://pachterlab.github.io/voyager/articles/vig2_visium.html


