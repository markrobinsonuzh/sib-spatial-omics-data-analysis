---
title: "Lattice Data Analysis"
author: "Samuel Gunz, Martin Emons, Mark D. Robinson"
format: html
editor: visual
---

# Introduction

In contrast to point pattern based methods, we can view the location of cells or spots in a fixed lattice and measure the corresponding marker expression at each location. HTS-based spatial transcriptomic technologies produce data on a regular lattice (i.e., evenly spaced spots or beads of uniform size and shape), whereas imaging-based technologies yield irregular lattice structures (i.e., with variable cell sizes and shapes, and non-uniform spacing).

For this representation of the cells we will rely on the `SpatialFeatureExperiment` package. For preprocessing of the dataset we refer the reader to the vignette of the `Voyager` package (Moses et al. 2023). The `Voyager` package also provides wrapper functions around the package `spdep` (Pebesma and Bivand 2023) that work directly on the `SpatialFeatureExperiment` object. The package `spdep` is designed for the ananlysis of spatial data with lattice structure.

## Dependencies

```{r}
source("utils.R")
theme_set(theme_light())
```

## Setup and Preprocessing

```{r}
# Load the dataset
sfe <- SFEData::McKellarMuscleData(dataset = "full")

# Filter and normalize the data
sfe_tissue <- sfe[, colData(sfe)$in_tissue]
sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,]
sfe_tissue <- scater::logNormCounts(sfe_tissue)
```

The `SpatialFeatureExperiment` objects is an extension to the `SpatiaExperiment` object. It additionally contains geometric annotations which are encoded as simple features of the `sf` library [add link and citation].

```{r}
sfe_tissue
```

For example, the spots of the Visium dataset are stored as a simple feature collection.

```{r}
colGeometry(sfe_tissue, "spotPoly") |> head()
```

# Lattice Data

## Definition

Lattice data refers to spatial data collected at fixed locations arranged in a regular or irregular grid (lattice). Each location has a defined spatial unit, and the sampling locations are fixed rather than random. This approach contrasts with point pattern analysis, where we assume that the locations were generated by a stochastic process [add citation].

```{r}
plotSpatialFeature(sfe_tissue,
                   "nCounts", 
                   colGeometryName = "spotPoly")
```

As can be seen here, the Visium dataset is a regular lattice. The color shows the number of counts detected in each Visium spot. In contrast, the outlines of individual cells after segmentaion could be seen as an irregular lattice.


```{r}
p <- plotSpatialFeature(sfe_tissue,
                   "nCounts", 
                   annotGeometryName = "myofiber_simplified")

cells <- annotGeometry(sfe_tissue, "myofiber_simplified") |> 
  st_geometry()

q <- ggplot() +
  geom_sf(data = cells, fill = NA) +
  theme_void()

(p | q)
```

## Spatial weight matrix

In lattice data analysis a key concept is the *spatial weight matrix*, which models the spatial relationships between units in the lattice (i.e., spots or cells). Various methods exist for constructing this matrix, such as contiguity-based (direct neighbors), graph-based, or distance-based methods [add citation].

For Visium, the most straightforward way is to take the next neighbours of each spot. This is done using the function `findVisiumGraph`.

```{r}
colGraph(sfe_tissue, "visium") <- findVisiumGraph(sfe_tissue)
```

```{r}
plotColGraph(sfe_tissue, 
             colGraphName = "visium",
             colGeometryName = "spotPoly") +
    theme_void()
```

In an irregular lattice the task of finding a spatial neighbourhood matrix is more complex, as different options exist. One option is to base the neighbourhood graph on neighbours that are in direct contact with each other. The method `poly2nb` creates a neihbourhood matrix with direct neighbours.

```{r}
annotGraph(sfe_tissue, "myofiber_poly2nb") <- 
  findSpatialNeighbors(sfe_tissue,
                       type = "myofiber_simplified",
                       MARGIN = 3,
                       method = "poly2nb", # wraps the spdep function with the same name
                       zero.policy = TRUE)
```


```{r}
plotAnnotGraph(sfe_tissue,
               annotGraphName = "myofiber_poly2nb", 
               annotGeometryName = "myofiber_simplified") + 
  theme_void()
```

Alternatively, we could take the five nearest neighbours of each cell. The graph looks quite distinct.

```{r}
annotGraph(sfe_tissue, "knn5") <- 
  findSpatialNeighbors(sfe_tissue,
                       type = "myofiber_simplified",
                       MARGIN = 3, # to use the annotation geometry
                       method = "knearneigh", # wraps the spdep function with the same name
                       k = 5,
                       zero.policy = TRUE)
```

```{r}
plotAnnotGraph(sfe_tissue,
               annotGraphName = "knn5", 
               annotGeometryName = "myofiber_simplified") + 
  theme_void()
```
<!-- In the case of Visium data, we don't have cell level gene expression information and therefore continue with the analysis using the spatial analysis of the regularly spaced spots. -->

# Spatial autocorrelation

Spatial autocorrelation measures the association between spatial units while recognizing that the spatial units are not independent measurements. These measures can be global (summarizing the entire field) or local (providing statistics for individual locations) [add citation].

# Global Measures

Global methods give us an overview over the entire field of view and summarize the spatial distribution of the cells (for a given measurement such as gene expression) in a single value. The metrics are a function of the weight matrix and the variables of interest.

In general, a global spatial autocorrelation measure has the form of a double sum over all locations $i,j$

$$\sum_i \sum_j f(x_i,x_j) w_{ij}$$

where $f(x_i,x_j)$ is the measure of association between features of interest and $w_{ij}$ scales the relationship by a spatial weight as defined in the weight matrix $W$ [add citation].

## Moran's I

Moran's I is the most prominent measure of spatial autocorrelation. The values are bounded by $-1$ and $1$. The expected value is close to $0$ for large $n$, the exact value is given by $\mathbb{E}(I) = -1/(n-1)$. A value higher than the expected value indicates spatial auto-correlation. Negative values indicate negative auto-correlation. Spatial auto-correlation means that similar values tend to be found together in the tissue. In fact, Moran's I can be interpreted as the Pearson correlation between the value at location $i$ and the averages value of the neigbours of $i$, (neighbours as defined in the weight matrix $W$) [add citation].

In the first example we will calculate Moran's I for the number of counts and genes measured in the Visium dataset. First we have a look at the distribution by eye.

```{r}
# TODO: change colors 

plotSpatialFeature(sfe_tissue, features = c("nCounts", "nGenes"),
                   colGeometryName = "spotPoly",
                   swap_rownames = "symbol")
```

```{r}
calculateUnivariate(t(colData(sfe_tissue)[,c("nCounts", "nGenes")]), 
                    type = "moran",
                    listw = colGraph(sfe_tissue, "visium"))
```

```{r}
sfe_tissue <- colDataUnivariate(sfe_tissue, features = c("nCounts", "nGenes"), 
                                colGraphName = "visium", nsim = 1000, type = "moran.mc")

plotMoranMC(sfe_tissue, c("nCounts", "nGenes"))
```
Here we can see the Moran's I values for the number of counts and genes that were identified in the Visium dataset and a permutation based null distribution. As we can see, the Moran's I values both indicates positive spatial autocorrelation and is highly significant.

This means that regions with similar count and number of measured gene values tend to cluster together. This is an interesting finding and was observed in other spatial transcriptomic datasets, see Bhuva et al., 2024, https://doi.org/10.1186/s13059-024-03241-7.


# Local Measures for Univariate Data

Often a global measure is not enough. One number determining e.g. the spatial autocorrelation over an entire tissue slice might not be reflective of tissue heterogeneity. Therefore, local indicators of spatial associations have been developed [add citation].

## Local Moran's I

Local Moran's I provides a measure of spatial autocorrelation at each location, highlighting local clusters of similarity or dissimilarity. Here will will caclulate the local Moran's I value for the measurment of muscle fiber marker gene [add citation].

```{r}
sfe_tissue <- runUnivariate(sfe_tissue, type = "localmoran", features = "Myh2",
                            colGraphName = "visium", swap_rownames = "symbol")

# TODO: change colors and color legend

# plot the expression values
plotSpatialFeature(sfe_tissue, features = c("Myh2"), colGeometryName = "spotPoly",
                   swap_rownames = "symbol")

# plot the local Moran's I values
plotLocalResult(sfe_tissue, "localmoran", features = c("Myh2"),
                colGeometryName = "spotPoly",swap_rownames = "symbol",
                divergent = TRUE, diverge_center = 0)

# plot the local Moran's I p-values
plotLocalResult(sfe_tissue, "localmoran", features = c("Myh2"), "-log10p_adj",
                colGeometryName = "spotPoly",swap_rownames = "symbol",
                divergent = TRUE, diverge_center = -log10(0.05))
```

In the local version of Moran's I the interpretation is the same as the global version). When interpreting local autocorrelation measures, it is important to consider both the effect size estimates and the significance level. Since the significance level is calculated for each spot separately, it is recommended to adjust for multiple testing (e.g., Benjamini and Hochberg methods). The local Moran's I statistics reveal locations in the tissue that have similar values to their neighbours (e.g., the upper part of the tissue). 

Your turn: try to recalculate the local Moran's I with gene `Myh1`. What do you notice?

```{r}
#| include: false
#| eval: false

sfe_tissue <- runUnivariate(sfe_tissue, type = "localmoran", features = "Myh1",
                            colGraphName = "visium", swap_rownames = "symbol")

# TODO: change colors and color legend

# plot the expression values
plotSpatialFeature(sfe_tissue, features = c("Myh1"), colGeometryName = "spotPoly",
                   swap_rownames = "symbol")

# plot the local Moran's I values
plotLocalResult(sfe_tissue, "localmoran", features = c("Myh1"),
                colGeometryName = "spotPoly",swap_rownames = "symbol",
                divergent = TRUE, diverge_center = 0)

# plot the local Moran's I p-values
plotLocalResult(sfe_tissue, "localmoran", features = c("Myh1"), "-log10p_adj",
                colGeometryName = "spotPoly",swap_rownames = "symbol",
                divergent = TRUE, diverge_center = -log10(0.05))
```

## Impact of neighbourhood on autocorrelation measures

Let's compare the impact of different neighbourhood matrices on local autocorrelation analysis. As it does not really make sense to do this with gene expression information, we calculate it with the area of the segmented cells. This could for instance be done when looking at local cell densities in a tissue.

First, based on the neighbourhood matrix based on contigous neighbours.

```{r}
sfe_tissue <- annotGeometryUnivariate(sfe_tissue, "localmoran", "area", 
                                      annotGeometryName = "myofiber_simplified",
                                      annotGraphName = "myofiber_poly2nb",
                                      include_self = FALSE, zero.policy = TRUE,
                                      name = "myofiber_poly2nb")

# TODO: change colors and color legend
plotLocalResult(sfe_tissue, "myofiber_poly2nb", "area", 
                annotGeometryName = "myofiber_simplified",
                 annotGraphName = "myofiber_poly2nb",
                divergent = TRUE, diverge_center = 0)
```
Second, based on the neighbourhood matrix based on the 5 nearest neighbours.

```{r}
sfe_tissue <- annotGeometryUnivariate(sfe_tissue, "localmoran", "area", 
                                      annotGeometryName = "myofiber_simplified",
                                      annotGraphName = "knn5",
                                      include_self = FALSE, zero.policy = TRUE,
                                      name = "knn5")
# TODO: change colors and color legend
plotLocalResult(sfe_tissue, "knn5", "area",
                annotGeometryName = "myofiber_simplified",
                annotGraphName = "knn5",
                divergent = TRUE, diverge_center = 0)
```

What do you notice? What happens if we set the nearest neighbourhood graph to 10 nearest neighbours?

# References

TODO: List references

This tutorial is partially based on the following `Voyager` vignette: https://pachterlab.github.io/voyager/articles/vig2_visium.html

```{r}
sessionInfo()
```



